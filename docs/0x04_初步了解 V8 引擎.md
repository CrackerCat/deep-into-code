# 初步了解 V8 引擎

V8 引擎本质上来说就是按照 ECMA 语法规范实现了堆内存管理 + 函数执行栈管理的高性能 JavaScript 引擎。

本文将会在上一节单独编译的 V8 引擎基础上借助于官方提供的 Hello World 例子来学习了解一些其内部的相关内容。

## I. 前言简介

V8 引擎本身其实只负责 JavaScript 的解析和执行，我们熟悉的不管是浏览器还是 Node.js 中的 Event Loop 以及随之附带的异步编程都不是引擎本身提供的。

另外还有一些非 ECMA 但是已经在 JavaScript 成为事实标准的必备 API，比如 `setTimeout`, `setInterval` 和 `console` 等也均不是 V8 引擎提供的，下面是一个简单的例子:

将官方的 `hello-world.cc` 的测试代码

```c
v8::Local<v8::String> source =
          v8::String::NewFromUtf8(isolate, "'Hello' + ', World!'",
                                  v8::NewStringType::kNormal)
              .ToLocalChecked();
```

修改为:

```c
v8::Local<v8::String> source =
          v8::String::NewFromUtf8(isolate, "console.log('Hello' + ', World!')",
                                  v8::NewStringType::kNormal)
              .ToLocalChecked();
```
可以看到输出结果变成了:

```bash
undefined
3 + 4 = 7
```

显然 V8 引擎原生并没有实现 `console.log`，继续测试下 `setTimeout`:

```c
v8::Local<v8::String> source =
          v8::String::NewFromUtf8(isolate, "setTimeout(()=>{  }, 1000)",
                                  v8::NewStringType::kNormal)
              .ToLocalChecked();
```

编译后执行输出:

```bash
<unknown>:0: Uncaught ReferenceError: setTimeout is not defined

#
# Fatal error in v8::ToLocalChecked
# Empty MaybeLocal.
#

Illegal instruction: 4
```

这里可以看到 `setTimeout` 也不是由引擎实现的。

实际上以 Node.js 为例，上述 API 均是 Node.js 借助于 Libuv 实现的，同时暴露方法给 JavaScript 使用，而在 Chrome 等浏览器环境下，这一层则有浏览器内核来负责实现，因此对于这些非 ECMA 的 API，不同的 JS 宿主环境各自的实现细节会有些微差异，这是对大家构建跨端环境下的 JavaScript 项目时需要关注的地方。

## II. 重要概念

### Isolate

第一个非常重要的概念是 `Isolate`，按照单词的意义可以理解为引擎的每一个 JS 运行时隔离环境，它本质上就是包含独立堆栈管理的 V8 运行时拷贝实例，也可以理解为相互独立的沙盒（SandBox），所以如果有两个 `Isolate`，它们可以并行来运行 JavaScript 代码而不会相互干扰。

### Context

每一个 `Isolate` 中 JavaScript 执行上环境，它允许独立无关的 JavaScript 代码在同一个 `Isolate` 实例中被正确的执行，也正为因为如此，开发者需要对每一段被执行 JavaScript 的代码来执行上下文。

### Local Handle

V8 实现了一套自动垃圾回收机制 (GC)，因此堆对象都由 `local handle` 进行统一管理，这也意味着开发者必须通过 `local handle` 来创建或者访问 V8 对象。

`local handle` 由 `handle scope` 来统一进行管理，通常我们会在函数作用域顶部申明:

```c
void test() {
  v8::HandleScope handle_scope(isolate);
  // ...
}
```

接下来 `test` 函数作作用域下创建的局部 `local handle` 变量都由这个申明的 `handle_scope` 来自动统一管理: 即当 `test` 函数执行完毕后会触发 `HandleScope` 析构，这一过程中会自动清理掉 `test` 函数内创建的 `local handle` 指向的 V8 对象。

这个过程其实也意味着通常情况下 `local handle` 的生命周期完全跟随 `handle scope`，因为如果我们想要在函数中返回一个 `local handle` 指向的 V8 不能直接 `return`，而需要使用另一种 `handle scope` 来管理，它是 `EscapableHandleScope`，下面是一个简单的例子:

```c
void test() {
  v8::EscapableHandleScope handle_scope(isolate);
  v8::Local<v8::String> str =
          v8::String::NewFromUtf8(isolate, "Hello world",
                                  v8::NewStringType::kNormal)
              .ToLocalChecked();

  // Return the value through Escape.
  return handle_scope.Escape(str);
}

```

`Escape` 顾名思义就是逃逸，这里就是让 `local handle` 指向的 V8 字符串对象 `str` 逃逸出 `handle scope` 的统一管理，那么其生命周期就得到了对应的延长。
