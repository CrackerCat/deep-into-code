# 初步了解 V8 引擎

V8 引擎本质上来说就是按照 ECMA 语法规范实现了堆内存管理 + 函数执行栈管理的高性能 JavaScript 引擎。

本文将会在上一节单独编译的 V8 引擎基础上借助于官方提供的 Hello World 例子来学习了解一些其内部的相关内容，以下内容基于 V8 版本为 `7.7.299.13`。

## I. 前言简介

V8 引擎本身其实只负责 JavaScript 的解析和执行，我们熟悉的不管是浏览器还是 Node.js 中的 Event Loop 以及随之附带的异步编程都不是引擎本身提供的。

另外还有一些非 ECMA 但是已经在 JavaScript 成为事实标准的必备 API，比如 `setTimeout`, `setInterval` 和 `console` 等也均不是 V8 引擎提供的，下面是一个简单的例子:

将官方的 `hello-world.cc` 的测试代码

```c
v8::Local<v8::String> source =
          v8::String::NewFromUtf8(isolate, "'Hello' + ', World!'",
                                  v8::NewStringType::kNormal)
              .ToLocalChecked();
```

修改为:

```c
v8::Local<v8::String> source =
          v8::String::NewFromUtf8(isolate, "console.log('Hello' + ', World!')",
                                  v8::NewStringType::kNormal)
              .ToLocalChecked();
```
可以看到输出结果变成了:

```bash
undefined
3 + 4 = 7
```

显然 V8 引擎原生并没有实现 `console.log`，继续测试下 `setTimeout`:

```c
v8::Local<v8::String> source =
          v8::String::NewFromUtf8(isolate, "setTimeout(()=>{  }, 1000)",
                                  v8::NewStringType::kNormal)
              .ToLocalChecked();
```

编译后执行输出:

```bash
<unknown>:0: Uncaught ReferenceError: setTimeout is not defined

#
# Fatal error in v8::ToLocalChecked
# Empty MaybeLocal.
#

Illegal instruction: 4
```

这里可以看到 `setTimeout` 也不是由引擎实现的。

实际上以 Node.js 为例，上述 API 均是 Node.js 借助于 Libuv 实现的，同时暴露方法给 JavaScript 使用，而在 Chrome 等浏览器环境下，这一层则有浏览器内核来负责实现，因此对于这些非 ECMA 的 API，不同的 JS 宿主环境各自的实现细节会有些微差异，这是对大家构建跨端环境下的 JavaScript 项目时需要关注的地方。

## II. 重要概念

### Isolate

第一个非常重要的概念是 `Isolate`，按照单词的意义可以理解为引擎的每一个 JS 运行时隔离环境，它本质上就是包含独立堆栈管理的 V8 运行时拷贝实例，也可以理解为相互独立的沙盒（SandBox），所以如果有两个 `Isolate`，它们可以并行来运行 JavaScript 代码而不会相互干扰。

### Context

每一个 `Isolate` 中 JavaScript 执行上环境，它允许独立无关的 JavaScript 代码在同一个 `Isolate` 实例中被正确的执行，也正为因为如此，开发者需要对每一段被执行 JavaScript 的代码来指定其执行上下文。

### Local Handle

V8 实现了一套自动垃圾回收机制 (GC)，因此堆对象都由 `local handle` 进行统一管理，这也意味着开发者必须通过 `local handle` 来创建或者访问 V8 对象。

`local handle` 由 `handle scope` 来统一进行管理，通常我们会在函数作用域顶部申明:

```c
void test() {
  v8::HandleScope handle_scope(isolate);
  // ...
}
```

接下来 `test` 函数作作用域下创建的局部 `local handle` 变量都由这个申明的 `handle_scope` 来自动统一管理: 即当 `test` 函数执行完毕后会触发 `HandleScope` 析构，这一过程中会自动清理掉 `test` 函数内创建的 `local handle` 指向的 V8 对象。

其实从这个角度来说，`handle scope` 的设计完全遵循了 `RAII` 的原则，因为 C++ 的标准保证了创建的对象离开作用域时其析构函数一定会被调用，所以即使在 `test` 函数中发生了异常，其作用域内部创建的 `local handle` 依旧可以得到释放。

这个过程其实也意味着通常情况下 `local handle` 的生命周期完全跟随 `handle scope`，因为如果我们想要在函数中返回一个 `local handle` 指向的 V8 不能直接 `return`，而需要使用另一种 `handle scope` 来管理，它是 `EscapableHandleScope`，下面是一个简单的例子:

```c
void test() {
  v8::EscapableHandleScope handle_scope(isolate);
  v8::Local<v8::String> str =
          v8::String::NewFromUtf8(isolate, "Hello world",
                                  v8::NewStringType::kNormal)
              .ToLocalChecked();

  // Return the value through Escape.
  return handle_scope.Escape(str);
}

```

`Escape` 顾名思义就是逃逸，这里就是让 `local handle` 指向的 V8 字符串对象 `str` 逃逸出 `handle scope` 的统一管理，那么其生命周期就得到了对应的延长。

### Persistent Handle

与其他通用语言的全局变量类似，我们在编写代码时可能会需要一些生命周期更加长的 `handle` 来指向 V8 对象，这里的生命周期更长是相对上面提到的 `local handle` 仅在函数作用域内生效且受到作用域顶部申明的 `HandleScope` 约束。

在这种情况下就会使用到 `persistent handle`，一个大家都见到过的例子就是 Chrome 中对 `Document Object Model` (DOM) 节点的引用在底层都是由 `persistent Handle` 来操作的。

`persistent handle` 更长的生命周期带来的一个副作用就是 V8 的 GC 默认不会回收其引用的 V8 对象，需要开发者在代码中来手动判断其指向的 V8 对象不再使用时将其变为弱引用，调用的方法是: `PersistentBase::SetWeak`，变为弱引用后，下一次 GC 时 V8 的垃圾回收器会自动将那些仅有 `weak persistent handle` 指向的堆对象回收掉。

### Garbage Collector

V8 引擎的垃圾回收机制 (GC) 正是基于上面提到的两种 `handle` 来实现的，因为开发者创建的 V8 对象都只能通过 `local handle` 或者 `persistent handle` 来进行操作，那也意味着每次触发 GC 时扫描整个堆上的对象可以通过以下规则来判断这个堆对象是否还在使用:

* 有 `local handle` 引用
* 有非 `weak` 状态的 `persistent handle` 引用

那么对于已经不再使用中的 V8 对象则可以清理掉以回收内存，限于篇幅这里对 GC 的描述比较简略，后面文章中会详细展开。

## III. 单线程 or 多线程

面试的时候都会被问到 JS 是单线程还是多线程的问题，虽然 ECMA 已经实施的标准中没有关于 Thread 的定义，但是使用 JS 编写多线程其实已经在 Node.js 的 `worker thread` 和浏览器中的 `web worker` 实现了。

其中 Node.js 中的 `worker thread` 是基于 Libuv 提供的多线程库实现的 (`uv_thread_create_ex`)，它限制了每一个线程的 `stack size` 为 4MB (v12.x)。

不过我们仍然不能据此就认为 JS 已经支持了多线程，因为这些多线程实现都不是在引擎层面而是由第三方模块做的，实际上在 V8 引擎里面，负责 JS 函数执行栈处理的依旧只有一个线程，我们可以认为它是 JS 主线程。

不过 V8 引擎本身也提供了一些辅助线程来处理诸如 GC 这样的操作，我们可以 debug 下官方提供的 Hello World 来看下线程信息。

### 调试官方示例

首先为了 debug 的时候能看到官方示例中的源代码信息，我们需要编译一个 debug 版本:

```bash
g++ -g -I. -Iinclude samples/hello-world.cc -o hello_world -lv8_monolith -Lout.gn/x64.release.sample/obj/ -pthread -std=c++0x
```

其实就比之前多了一个参数 `-g`，这里我们使用 `lldb` 进行调试，MacOS 安装 `XCode` 后自带，Windows 的同学可以参见之前的文章在子系统中自行编译 `llvm` 来使用 `lldb`:

```bash
lldb -- hello_world
(lldb) target create "hello_world"
Current executable set to 'hello_world' (x86_64).
```

然后设置断点在 `main` 函数上:

```bash
(lldb) breakpoint set --name main
Breakpoint 1: where = hello_world`main + 34 at hello-world.cc:14:40, address = 0x0000000100000e02
```

最后开始运行:

```bash
(lldb) run
Process 27404 launched: '/Users/hyj1991/git/v8_base/v8/v8/hello_world' (x86_64)
Process 27404 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100000e02 hello_world`main(argc=1, argv=0x00007ffeefbff808) at hello-world.cc:14:40
   11  	
   12  	int main(int argc, char* argv[]) {
   13  	  // Initialize V8.
-> 14  	  v8::V8::InitializeICUDefaultLocation(argv[0]);
   15  	  v8::V8::InitializeExternalStartupData(argv[0]);
   16  	  std::unique_ptr<v8::Platform> platform = v8::platform::NewDefaultPlatform();
   17  	  v8::V8::InitializePlatform(platform.get());
Target 0: (hello_world) stopped.
```

此时我们可以先看下当前的线程数量:

```bash
(lldb) thread list
Process 27404 stopped
* thread #1: tid = 0xba8804, 0x0000000100000e02 hello_world`main(argc=1, argv=0x00007ffeefbff808) at hello-world.cc:14:40, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
```

可以看到只有一个主线程，符合预期，继续 `next` 三次到执行完毕 `v8::platform::NewDefaultPlatform()` 方法:

```bash
(lldb) next
Process 27404 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = step over
    frame #0: 0x0000000100000e83 hello_world`main(argc=1, argv=0x00007ffeefbff808) at hello-world.cc:17:39
   14  	  v8::V8::InitializeICUDefaultLocation(argv[0]);
   15  	  v8::V8::InitializeExternalStartupData(argv[0]);
   16  	  std::unique_ptr<v8::Platform> platform = v8::platform::NewDefaultPlatform();
-> 17  	  v8::V8::InitializePlatform(platform.get());
   18  	  v8::V8::Initialize();
   19  	
   20  	  // Create a new Isolate and make it the current one.
Target 0: (hello_world) stopped.
```

此时继续查看线程数量:

```bash
(lldb) thread list
Process 27404 stopped
* thread #1: tid = 0xba8804, 0x0000000100000e83 hello_world`main(argc=1, argv=0x00007ffeefbff808) at hello-world.cc:17:39, queue = 'com.apple.main-thread', stop reason = step over
  thread #2: tid = 0xba8e86, 0x00000001018e4d30 dyld`ImageLoaderMachOCompressed::libImage(unsigned int) const, name = 'V8 DefaultWorke'
  thread #3: tid = 0xba8e87, 0x00007fff7f659f02 libsystem_kernel.dylib`__psynch_mutexwait + 10, name = 'V8 DefaultWorke'
  thread #4: tid = 0xba8e88, 0x00000001018dc428 dyld`ImageLoader::trieWalk(unsigned char const*, unsigned char const*, char const*) + 140
  thread #5: tid = 0xba8e89, 0x00007fff7f659f02 libsystem_kernel.dylib`__psynch_mutexwait + 10
  thread #6: tid = 0xba8e8a, 0x00007fff7f659f02 libsystem_kernel.dylib`__psynch_mutexwait + 10, name = 'V8 DefaultWorke'
  thread #7: tid = 0xba8e8b, 0x00007fff7f659f02 libsystem_kernel.dylib`__psynch_mutexwait + 10
  thread #8: tid = 0xba8e8c, 0x00007fff7f659f02 libsystem_kernel.dylib`__psynch_mutexwait + 10
```

可以看到线程数量变成了 8 个，也就是初始化完 `platform` 后多了 7 个后台线程，这是什么时候创建的呢，下面我们来看下这额外的 7 个线程是哪里创建的。

### 创建的额外线程

我们可以重新按照上面小节中的方法来进入示例的调试，这次我们直接 `step` 进入到 `v8::platform::NewDefaultPlatform()` 里面:

```bash
(lldb) step
Process 28136 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = step in
    frame #0: 0x0000000100013c3a hello_world`v8::platform::NewDefaultPlatform(thread_pool_size=0, idle_task_support=kDisabled, in_process_stack_dumping=kDisabled, tracing_controller=unique_ptr<v8::TracingController, std::__1::default_delete<v8::TracingController> > @ 0x00007ffeefbff5f8) at default-platform.cc:38:32 [opt]
   35  	    int thread_pool_size, IdleTaskSupport idle_task_support,
   36  	    InProcessStackDumping in_process_stack_dumping,
   37  	    std::unique_ptr<v8::TracingController> tracing_controller) {
-> 38  	  if (in_process_stack_dumping == InProcessStackDumping::kEnabled) {
   39  	    v8::base::debug::EnableInProcessStackDumping();
   40  	  }
   41  	  std::unique_ptr<DefaultPlatform> platform(
Target 0: (hello_world) stopped.
```

这里可以看到 `v8::platform::NewDefaultPlatform()` 函数有一个参数 `thread_pool_size`，其默认值为 0:

```bash
(lldb) frame variable thread_pool_size
(int) thread_pool_size = 0
```

继续 `next` 到 `platform->SetThreadPoolSize(thread_pool_size)` 这一行，这里显然是计算真正的线程池线程数的地方，`step` 进入一探究竟:

```bash
   92  	void DefaultPlatform::SetThreadPoolSize(int thread_pool_size) {
   93  	  base::MutexGuard guard(&lock_);
   94  	  DCHECK_GE(thread_pool_size, 0);
   95  	  if (thread_pool_size < 1) {
   96  	    thread_pool_size = base::SysInfo::NumberOfProcessors() - 1;
   97  	  }
   98  	  thread_pool_size_ =
-> 99  	      std::max(std::min(thread_pool_size, kMaxThreadPoolSize), 1);
   100 	}
Target 0: (hello_world) stopped.
```

好了这里就非常清晰了，如果 `thread_pool_size` 值小于 1，就默认将线程池大小设置为计算器的 CPU 逻辑核数 - 1，这里减去 1 显然是为了排除对主线程的干扰，毕竟不管如何 JS 主线程是一定会有的。

这些辅助线程是在计算完毕真正的 `thread_pool_size` 大小后， 早 `platform->EnsureBackgroundTaskRunnerInitialized()` 中被启动:

```c
void DefaultPlatform::EnsureBackgroundTaskRunnerInitialized() {
  base::MutexGuard guard(&lock_);
  if (!worker_threads_task_runner_) {
    worker_threads_task_runner_ =
        std::make_shared<DefaultWorkerThreadsTaskRunner>(
            thread_pool_size_, time_function_for_testing_
                                   ? time_function_for_testing_
                                   : DefaultTimeFunction);
  }
}
```

这里用了共享智能指针来创建 `DefaultWorkerThreadsTaskRunner`，我们来看下其构造函数:

```c
DefaultWorkerThreadsTaskRunner::DefaultWorkerThreadsTaskRunner(
    uint32_t thread_pool_size, TimeFunction time_function)
    : queue_(time_function),
      time_function_(time_function),
      thread_pool_size_(thread_pool_size) {
  for (uint32_t i = 0; i < thread_pool_size; ++i) {
    thread_pool_.push_back(base::make_unique<WorkerThread>(this));
  }
}
```

可以看到这里正是使用了一个 `for` 循环来根据前面计算得到的 `thread_pool_size` 值来创建这些额外的辅助线程。

因为我的机器 CPU 逻辑核数为 8，这里就会创建 7 个额外的辅助线程，回到上一小节中的 `thread list` 结果，可以看到除去主线程确实多了 7 个辅助线程。

多提一句，负责管理和创建辅助线程的 `WorkerThread` 类其实已经实现了跨平台，在 `posix` 平台下直接使用 `pthread_create` 来创建线程；而在 `win32` 平台下则使用了 `_beginthreadex`，详细的代码在 `src/base/platform` 下可以看到。

## IV. 逆工程 V8 对象

其实所谓的逆工程，就是根据 V8 设计的对 JS 对象存储结构的描述，开发者可以实现在进程运行内存空间中或者进程崩溃后的 Core 文件还原的内存空间中来反推出当前 JS 代码运行状态和 JS 对象在堆空间的分配状况的一种技术。

这里我们首先来看逆工程 V8 对象的原理，那么我们需要来理解 V8 本身设计的对象布局。

### Tagged Pointer

我们先来介绍认识一种特殊类型的指针: `Tagged Pointer`，这里虽然说是特殊，其实从存储或者占用空间大小来说并没有什么特别的地方:

* 32 位操作系统: 4 byte 32 bit
* 64 位操作系统: 8 byte 64 bit

我们可以看到，如果程序被设计为按照 4 byte 或者 8 byte 地址对齐来实现最佳的运行效率，那么指针的最后 2 位 (32 位操作系统) 或者 3 位 (64 位操作系统) 下一定都是 0，这样某种程度上对于昂贵的内存空间来说是一种浪费。

`Tagged Pointer` 就是利用指针最后相同的几位来实现将传统指针区分为不同数据类型的一种历史悠久的实现，具体到 V8 引擎中，它将最后一位 (bit) 通过 0 或者 1 来区分要将当前的指针解析为小整形 (Smi) 或者一个常规的指针:

* 最后一位为 0: 小整形 (Smi)
* 最后一位为 1: 指向堆对象的常规指针 (需要转换)

实际上 V8 中对 `Smi Tag` 的描述在 `include/v8-internal.h` 中:

```c
// Tag information for Smi.
const int kSmiTag = 0;
const int kSmiTagSize = 1;
const intptr_t kSmiTagMask = (1 << kSmiTagSize) - 1;
```

这里和上文的描述是吻合的。

其实引擎之所以这样处理，是因为在 ECMA 规范中，JS 中所有的 `Number` 类型数据都是被描述要基于 `IEEE-754` 双精度浮点型，而我们都知道，CPU 操作浮点数的效率远低于整数，而开发者对于整数的使用又是一个非常普遍的需求: 比如循环计数控制或者数组下标索引等，因此为了程序执行效率的提升引擎需要将 **一定范围** 内的整数直接将原始指针进行转换后读取。

### Small Integer (Smi)

上面一小节中其实也提到，`Tagged Pointer` 只能用来描述 **一定范围** 内的整数大小，那么这个范围具体是多大呢，我们可以继续来从源码中找到答案。

在 `include/v8-internal.h` 中，首先通过模板定义了 32 位操作系统下的 `Smi Tag` 信息:

```c
// Smi constants for systems where tagged pointer is a 32-bit value.
template <>
struct SmiTagging<4> {
  enum { kSmiShiftSize = 0, kSmiValueSize = 31 };

  static constexpr intptr_t kSmiMinValue =
      static_cast<intptr_t>(kUintptrAllBitsSet << (kSmiValueSize - 1));
  static constexpr intptr_t kSmiMaxValue = -(kSmiMinValue + 1);
};
```
这里很显然，32 位操作系统下的 `Tagged Pointer`，去掉最后一位的标记位，因此用来表示 Smi 值只有 32 位，所以 `kSmiValueSize` 为 31。

下面的部分则是计算此时能表示的最大整数: `2^(31 - 1) - 1 = 1073741823` (有符号)，所以 32 位下 Smi 的表示范围为: `-1073741823 ~ 1073741823`。

接着看下64 位操作系统下的 `Smi Tag` 信息:

```c
// Smi constants for systems where tagged pointer is a 64-bit value.
template <>
struct SmiTagging<8> {
  enum { kSmiShiftSize = 31, kSmiValueSize = 32 };
};
```

同样的部分就补贴了，这里可以看到 Smi 的范围增加了一位，所以表示的范围也增加到: `-2147483647 ~ 2147483647`。

当然有意思的是 V8 引擎为了某些场景下需要跨平台程序完全一致性也提供了一个宏 `V8_31BIT_SMIS_ON_64BIT_ARCH`:

```c
#ifdef V8_31BIT_SMIS_ON_64BIT_ARCH
using PlatformSmiTagging = SmiTagging<kApiInt32Size>;
#else
using PlatformSmiTagging = SmiTagging<kApiTaggedSize>;
#endif
```

如果定义了这个宏的话，则在 64 位操作系统下会使用和 32 位操作系统下范围完全一致的 Smi。

有了上面的知识，还原给定的一个内存空间地址 `p` 对应的 Smi 值就很简单了，首先根据掩码判断 `p` 是否为 Smi:

```c
bool Smi::Check(int64_t p) const {
  return (p & kSmiTagMask) == kSmiTag;
}
```

如果是 Smi，则将地址右移 `kSmiShiftSize + kSmiTagMask` 位得到记录的原始 int 值:

```c
int64_t Smi::GetValue(int64_t p) const {
  return p >> (kSmiShiftSize + kSmiTagMask);
}
```

这样就完成了将一个实际保存了 Smi 的 `Tagged Pointer` 逆工程为其原始保存的 int 值的过程。

### Heap Object

上一小节中实现的 `Smi::Check` 方法可以对给定的地址 `p` 来判断其最终存储 / 指向的是 Smi 还是一个 V8 对象，`kSmiTag` 目前在引擎中值为 `0`，显然当 `p` 的最后一位为 `1` 时 `Check` 方法返回 `false`，这里就意味着所有的值为奇数的地址实际都指向一个 V8 对象，我们也可以称之为 `Heap Object`。

如果开发同学曾经因为 JS 的内存问题在 Node.js 或者浏览器中导出过堆快照，并且在 Chrome devtools 中解析，那么就会发现所有的以 `@` 符号开始对象地址都是奇数，这里也从侧面印证了这一论述。

对于这个给定的奇数地址 `p`，我们要将其逆工程回真正指向的 `Heap Object` 会复杂一些，我们来看下如何处理。

V8 基于自己的规则实现了一套对象布局方式，用 OOP 的方式来描述，所有的 JS 对象类型布局全部都继承自 `Heap Object` 的布局方式，其实这个也很好理解，毕竟所有 JS 对象本身就是从 `Heap Object` 派生出来的。

我们先来看下引擎对 `Heap Object` 的布局描述:

```c
// src/objects/heap-object.h
// Layout description.
#define HEAP_OBJECT_FIELDS(V) \
  V(kMapOffset, kTaggedSize)  \
  /* Header size. */          \
  V(kHeaderSize, 0)

  DEFINE_FIELD_OFFSET_CONSTANTS(Object::kHeaderSize, HEAP_OBJECT_FIELDS)
#undef HEAP_OBJECT_FIELDS
```

其中 `DEFINE_FIELD_OFFSET_CONSTANTS` 宏是一个用来定义枚举类型的宏，其定义为:

```c
// src/utils/utils.h
#define DEFINE_FIELD_OFFSET_CONSTANTS(StartOffset, LIST_MACRO) \
  enum {                                                       \
    LIST_MACRO##_StartOffset = StartOffset - 1,                \
    LIST_MACRO(DEFINE_ONE_FIELD_OFFSET)                        \
  };
```

里面的 `DEFINE_ONE_FIELD_OFFSET` 宏定义为:

```c
// src/utils/utils.h
#define DEFINE_ONE_FIELD_OFFSET(Name, Size) Name, Name##End = Name + (Size)-1,
```

宏嵌套宏看起来比较复杂，但是其实它们的本质还是减少重复代码的编写，这里我们直接将 `Heap Object` 的布局定义宏全部展开:

```c
enum {
  HEAP_OBJECT_FIELDS_StartOffset = Object::kHeaderSize - 1,
  kMapOffset,
  kMapOffsetEnd = kMapOffset + (kTaggedSize)-1,
  kHeaderSize,
  kHeaderSizeEnd = kHeaderSize + (0) - 1,
};
```

这样就很清晰了，可以看到宏展开后就是一个描述布局方式的枚举，这里 `Heap Object` 的布局接在 `Object` 之后，它的核心只定义了一个指向 `Map` 的伪指针。

伪指针定义可以参见 [Tagged Pointer](/0x04_初步了解%20V8%20引擎.html#tagged-pointer)，它的大小和系统的指针大小完全一致，32 位系统上为 4 byte，64 位系统上为 8 byte。

:::warning MetaMap
这里的 `Map` 和我们在 JS 代码中使用的 `Map` 完全不是一个东西，它其实是包含描述指向它的 `Heap Object` 的结构信息的特殊 `Heap Object`，即经常被提到的 `Hidden Class`。
:::